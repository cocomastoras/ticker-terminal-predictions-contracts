/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type { BaseContract, BigNumberish, BytesLike, FunctionFragment, Result, Interface, AddressLike, ContractRunner, ContractMethod, Listener } from "ethers"
import type { TypedContractEvent, TypedDeferredTopicFilter, TypedEventLog, TypedListener, TypedContractMethod } from "./common.js"
  
export declare namespace L1Read {
      
    export type AccountMarginSummaryStruct = {accountValue: BigNumberish, marginUsed: BigNumberish, ntlPos: BigNumberish, rawUsd: BigNumberish}

    export type AccountMarginSummaryStructOutput = [accountValue: bigint, marginUsed: bigint, ntlPos: bigint, rawUsd: bigint] & {accountValue: bigint, marginUsed: bigint, ntlPos: bigint, rawUsd: bigint }
  

    export type BboStruct = {bid: BigNumberish, ask: BigNumberish}

    export type BboStructOutput = [bid: bigint, ask: bigint] & {bid: bigint, ask: bigint }
  

    export type CoreUserExistsStruct = {exists: boolean}

    export type CoreUserExistsStructOutput = [exists: boolean] & {exists: boolean }
  

    export type DelegationStruct = {validator: AddressLike, amount: BigNumberish, lockedUntilTimestamp: BigNumberish}

    export type DelegationStructOutput = [validator: string, amount: bigint, lockedUntilTimestamp: bigint] & {validator: string, amount: bigint, lockedUntilTimestamp: bigint }
  

    export type DelegatorSummaryStruct = {delegated: BigNumberish, undelegated: BigNumberish, totalPendingWithdrawal: BigNumberish, nPendingWithdrawals: BigNumberish}

    export type DelegatorSummaryStructOutput = [delegated: bigint, undelegated: bigint, totalPendingWithdrawal: bigint, nPendingWithdrawals: bigint] & {delegated: bigint, undelegated: bigint, totalPendingWithdrawal: bigint, nPendingWithdrawals: bigint }
  

    export type PerpAssetInfoStruct = {coin: string, marginTableId: BigNumberish, szDecimals: BigNumberish, maxLeverage: BigNumberish, onlyIsolated: boolean}

    export type PerpAssetInfoStructOutput = [coin: string, marginTableId: bigint, szDecimals: bigint, maxLeverage: bigint, onlyIsolated: boolean] & {coin: string, marginTableId: bigint, szDecimals: bigint, maxLeverage: bigint, onlyIsolated: boolean }
  

    export type PositionStruct = {szi: BigNumberish, entryNtl: BigNumberish, isolatedRawUsd: BigNumberish, leverage: BigNumberish, isIsolated: boolean}

    export type PositionStructOutput = [szi: bigint, entryNtl: bigint, isolatedRawUsd: bigint, leverage: bigint, isIsolated: boolean] & {szi: bigint, entryNtl: bigint, isolatedRawUsd: bigint, leverage: bigint, isIsolated: boolean }
  

    export type SpotBalanceStruct = {total: BigNumberish, hold: BigNumberish, entryNtl: BigNumberish}

    export type SpotBalanceStructOutput = [total: bigint, hold: bigint, entryNtl: bigint] & {total: bigint, hold: bigint, entryNtl: bigint }
  

    export type SpotInfoStruct = {name: string, tokens: [BigNumberish, BigNumberish]}

    export type SpotInfoStructOutput = [name: string, tokens: [bigint, bigint]] & {name: string, tokens: [bigint, bigint] }
  

    export type TokenInfoStruct = {name: string, spots: BigNumberish[], deployerTradingFeeShare: BigNumberish, deployer: AddressLike, evmContract: AddressLike, szDecimals: BigNumberish, weiDecimals: BigNumberish, evmExtraWeiDecimals: BigNumberish}

    export type TokenInfoStructOutput = [name: string, spots: bigint[], deployerTradingFeeShare: bigint, deployer: string, evmContract: string, szDecimals: bigint, weiDecimals: bigint, evmExtraWeiDecimals: bigint] & {name: string, spots: bigint[], deployerTradingFeeShare: bigint, deployer: string, evmContract: string, szDecimals: bigint, weiDecimals: bigint, evmExtraWeiDecimals: bigint }
  

    export type UserBalanceStruct = {user: AddressLike, balance: BigNumberish}

    export type UserBalanceStructOutput = [user: string, balance: bigint] & {user: string, balance: bigint }
  

    export type TokenSupplyStruct = {maxSupply: BigNumberish, totalSupply: BigNumberish, circulatingSupply: BigNumberish, futureEmissions: BigNumberish, nonCirculatingUserBalances: L1Read.UserBalanceStruct[]}

    export type TokenSupplyStructOutput = [maxSupply: bigint, totalSupply: bigint, circulatingSupply: bigint, futureEmissions: bigint, nonCirculatingUserBalances: L1Read.UserBalanceStructOutput[]] & {maxSupply: bigint, totalSupply: bigint, circulatingSupply: bigint, futureEmissions: bigint, nonCirculatingUserBalances: L1Read.UserBalanceStructOutput[] }
  

    export type UserVaultEquityStruct = {equity: BigNumberish, lockedUntilTimestamp: BigNumberish}

    export type UserVaultEquityStructOutput = [equity: bigint, lockedUntilTimestamp: bigint] & {equity: bigint, lockedUntilTimestamp: bigint }
  

    export type WithdrawableStruct = {withdrawable: BigNumberish}

    export type WithdrawableStructOutput = [withdrawable: bigint] & {withdrawable: bigint }
  
    }

  export interface L1ReadInterface extends Interface {
    getFunction(nameOrSignature: "accountMarginSummary" | "bbo" | "coreUserExists" | "delegations" | "delegatorSummary" | "l1BlockNumber" | "markPx" | "oraclePx" | "perpAssetInfo" | "position" | "spotBalance" | "spotInfo" | "spotPx" | "tokenInfo" | "tokenSupply" | "userVaultEquity" | "withdrawable"): FunctionFragment;

    

    encodeFunctionData(functionFragment: 'accountMarginSummary', values: [BigNumberish, AddressLike]): string;
encodeFunctionData(functionFragment: 'bbo', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'coreUserExists', values: [AddressLike]): string;
encodeFunctionData(functionFragment: 'delegations', values: [AddressLike]): string;
encodeFunctionData(functionFragment: 'delegatorSummary', values: [AddressLike]): string;
encodeFunctionData(functionFragment: 'l1BlockNumber', values?: undefined): string;
encodeFunctionData(functionFragment: 'markPx', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'oraclePx', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'perpAssetInfo', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'position', values: [AddressLike, BigNumberish]): string;
encodeFunctionData(functionFragment: 'spotBalance', values: [AddressLike, BigNumberish]): string;
encodeFunctionData(functionFragment: 'spotInfo', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'spotPx', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'tokenInfo', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'tokenSupply', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'userVaultEquity', values: [AddressLike, AddressLike]): string;
encodeFunctionData(functionFragment: 'withdrawable', values: [AddressLike]): string;

    decodeFunctionResult(functionFragment: 'accountMarginSummary', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'bbo', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'coreUserExists', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'delegations', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'delegatorSummary', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'l1BlockNumber', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'markPx', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'oraclePx', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'perpAssetInfo', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'position', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'spotBalance', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'spotInfo', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'spotPx', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'tokenInfo', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'tokenSupply', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'userVaultEquity', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'withdrawable', data: BytesLike): Result;
  }

  

  export interface L1Read extends BaseContract {
    
    connect(runner?: ContractRunner | null): L1Read;
    waitForDeployment(): Promise<this>;

    interface: L1ReadInterface;

    
  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TypedEventLog<TCEvent>>>
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>
  on<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>
  
  once<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>
  once<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>
  removeAllListeners<TCEvent extends TypedContractEvent>(event?: TCEvent): Promise<this>


    
    
    accountMarginSummary: TypedContractMethod<
      [perp_dex_index: BigNumberish, user: AddressLike, ],
      [L1Read.AccountMarginSummaryStructOutput],
      'view'
    >
    

    
    bbo: TypedContractMethod<
      [asset: BigNumberish, ],
      [L1Read.BboStructOutput],
      'view'
    >
    

    
    coreUserExists: TypedContractMethod<
      [user: AddressLike, ],
      [L1Read.CoreUserExistsStructOutput],
      'view'
    >
    

    
    delegations: TypedContractMethod<
      [user: AddressLike, ],
      [L1Read.DelegationStructOutput[]],
      'view'
    >
    

    
    delegatorSummary: TypedContractMethod<
      [user: AddressLike, ],
      [L1Read.DelegatorSummaryStructOutput],
      'view'
    >
    

    
    l1BlockNumber: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    markPx: TypedContractMethod<
      [index: BigNumberish, ],
      [bigint],
      'view'
    >
    

    
    oraclePx: TypedContractMethod<
      [index: BigNumberish, ],
      [bigint],
      'view'
    >
    

    
    perpAssetInfo: TypedContractMethod<
      [perp: BigNumberish, ],
      [L1Read.PerpAssetInfoStructOutput],
      'view'
    >
    

    
    position: TypedContractMethod<
      [user: AddressLike, perp: BigNumberish, ],
      [L1Read.PositionStructOutput],
      'view'
    >
    

    
    spotBalance: TypedContractMethod<
      [user: AddressLike, token: BigNumberish, ],
      [L1Read.SpotBalanceStructOutput],
      'view'
    >
    

    
    spotInfo: TypedContractMethod<
      [spot: BigNumberish, ],
      [L1Read.SpotInfoStructOutput],
      'view'
    >
    

    
    spotPx: TypedContractMethod<
      [index: BigNumberish, ],
      [bigint],
      'view'
    >
    

    
    tokenInfo: TypedContractMethod<
      [token: BigNumberish, ],
      [L1Read.TokenInfoStructOutput],
      'view'
    >
    

    
    tokenSupply: TypedContractMethod<
      [token: BigNumberish, ],
      [L1Read.TokenSupplyStructOutput],
      'view'
    >
    

    
    userVaultEquity: TypedContractMethod<
      [user: AddressLike, vault: AddressLike, ],
      [L1Read.UserVaultEquityStructOutput],
      'view'
    >
    

    
    withdrawable: TypedContractMethod<
      [user: AddressLike, ],
      [L1Read.WithdrawableStructOutput],
      'view'
    >
    


    getFunction<T extends ContractMethod = ContractMethod>(key: string | FunctionFragment): T;

    getFunction(nameOrSignature: 'accountMarginSummary'): TypedContractMethod<
      [perp_dex_index: BigNumberish, user: AddressLike, ],
      [L1Read.AccountMarginSummaryStructOutput],
      'view'
    >;
getFunction(nameOrSignature: 'bbo'): TypedContractMethod<
      [asset: BigNumberish, ],
      [L1Read.BboStructOutput],
      'view'
    >;
getFunction(nameOrSignature: 'coreUserExists'): TypedContractMethod<
      [user: AddressLike, ],
      [L1Read.CoreUserExistsStructOutput],
      'view'
    >;
getFunction(nameOrSignature: 'delegations'): TypedContractMethod<
      [user: AddressLike, ],
      [L1Read.DelegationStructOutput[]],
      'view'
    >;
getFunction(nameOrSignature: 'delegatorSummary'): TypedContractMethod<
      [user: AddressLike, ],
      [L1Read.DelegatorSummaryStructOutput],
      'view'
    >;
getFunction(nameOrSignature: 'l1BlockNumber'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'markPx'): TypedContractMethod<
      [index: BigNumberish, ],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'oraclePx'): TypedContractMethod<
      [index: BigNumberish, ],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'perpAssetInfo'): TypedContractMethod<
      [perp: BigNumberish, ],
      [L1Read.PerpAssetInfoStructOutput],
      'view'
    >;
getFunction(nameOrSignature: 'position'): TypedContractMethod<
      [user: AddressLike, perp: BigNumberish, ],
      [L1Read.PositionStructOutput],
      'view'
    >;
getFunction(nameOrSignature: 'spotBalance'): TypedContractMethod<
      [user: AddressLike, token: BigNumberish, ],
      [L1Read.SpotBalanceStructOutput],
      'view'
    >;
getFunction(nameOrSignature: 'spotInfo'): TypedContractMethod<
      [spot: BigNumberish, ],
      [L1Read.SpotInfoStructOutput],
      'view'
    >;
getFunction(nameOrSignature: 'spotPx'): TypedContractMethod<
      [index: BigNumberish, ],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'tokenInfo'): TypedContractMethod<
      [token: BigNumberish, ],
      [L1Read.TokenInfoStructOutput],
      'view'
    >;
getFunction(nameOrSignature: 'tokenSupply'): TypedContractMethod<
      [token: BigNumberish, ],
      [L1Read.TokenSupplyStructOutput],
      'view'
    >;
getFunction(nameOrSignature: 'userVaultEquity'): TypedContractMethod<
      [user: AddressLike, vault: AddressLike, ],
      [L1Read.UserVaultEquityStructOutput],
      'view'
    >;
getFunction(nameOrSignature: 'withdrawable'): TypedContractMethod<
      [user: AddressLike, ],
      [L1Read.WithdrawableStructOutput],
      'view'
    >;

    

    filters: {
      
    };
  }