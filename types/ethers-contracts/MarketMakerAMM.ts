/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type { BaseContract, BigNumberish, BytesLike, FunctionFragment, Result, Interface, EventFragment, AddressLike, ContractRunner, ContractMethod, Listener } from "ethers"
import type { TypedContractEvent, TypedDeferredTopicFilter, TypedEventLog, TypedLogDescription, TypedListener, TypedContractMethod } from "./common.js"
  
export declare namespace MarketMakerAMM {
      
    export type MarketDataWithHistoryStruct = {marketId: BigNumberish, roundId: BigNumberish, roundStart: BigNumberish, marketTreasury: BigNumberish, yesReserves: BigNumberish, noReserves: BigNumberish, outYesReserves: BigNumberish, outNoReserves: BigNumberish, lastPrice: BigNumberish, currentPrice: BigNumberish, result: BigNumberish, delistingRound: BigNumberish, history: BigNumberish[]}

    export type MarketDataWithHistoryStructOutput = [marketId: bigint, roundId: bigint, roundStart: bigint, marketTreasury: bigint, yesReserves: bigint, noReserves: bigint, outYesReserves: bigint, outNoReserves: bigint, lastPrice: bigint, currentPrice: bigint, result: bigint, delistingRound: bigint, history: bigint[]] & {marketId: bigint, roundId: bigint, roundStart: bigint, marketTreasury: bigint, yesReserves: bigint, noReserves: bigint, outYesReserves: bigint, outNoReserves: bigint, lastPrice: bigint, currentPrice: bigint, result: bigint, delistingRound: bigint, history: bigint[] }
  

    export type MarketDataStruct = {marketId: BigNumberish, roundId: BigNumberish, roundStart: BigNumberish, marketTreasury: BigNumberish, yesReserves: BigNumberish, noReserves: BigNumberish, outYesReserves: BigNumberish, outNoReserves: BigNumberish, lastPrice: BigNumberish, currentPrice: BigNumberish, result: BigNumberish}

    export type MarketDataStructOutput = [marketId: bigint, roundId: bigint, roundStart: bigint, marketTreasury: bigint, yesReserves: bigint, noReserves: bigint, outYesReserves: bigint, outNoReserves: bigint, lastPrice: bigint, currentPrice: bigint, result: bigint] & {marketId: bigint, roundId: bigint, roundStart: bigint, marketTreasury: bigint, yesReserves: bigint, noReserves: bigint, outYesReserves: bigint, outNoReserves: bigint, lastPrice: bigint, currentPrice: bigint, result: bigint }
  

    export type MarketHistoryStruct = {marketId: BigNumberish, roundId: BigNumberish, outYesReserves: BigNumberish, outNoReserves: BigNumberish, openPrice: BigNumberish, closePrice: BigNumberish, result: BigNumberish}

    export type MarketHistoryStructOutput = [marketId: bigint, roundId: bigint, outYesReserves: bigint, outNoReserves: bigint, openPrice: bigint, closePrice: bigint, result: bigint] & {marketId: bigint, roundId: bigint, outYesReserves: bigint, outNoReserves: bigint, openPrice: bigint, closePrice: bigint, result: bigint }
  

    export type UserDataStruct = {marketId: BigNumberish, roundId: BigNumberish, result: BigNumberish, outYesReserves: BigNumberish, outNoReserves: BigNumberish, userYesReserves: BigNumberish, userNoReserves: BigNumberish, treasury: BigNumberish, userRedeemed: BigNumberish}

    export type UserDataStructOutput = [marketId: bigint, roundId: bigint, result: bigint, outYesReserves: bigint, outNoReserves: bigint, userYesReserves: bigint, userNoReserves: bigint, treasury: bigint, userRedeemed: bigint] & {marketId: bigint, roundId: bigint, result: bigint, outYesReserves: bigint, outNoReserves: bigint, userYesReserves: bigint, userNoReserves: bigint, treasury: bigint, userRedeemed: bigint }
  

    export type UserToRoundsPerMarketStruct = {marketId: BigNumberish, roundIds: BigNumberish[]}

    export type UserToRoundsPerMarketStructOutput = [marketId: bigint, roundIds: bigint[]] & {marketId: bigint, roundIds: bigint[] }
  
    }

  export interface MarketMakerAMMInterface extends Interface {
    getFunction(nameOrSignature: "checkResolutionStatus" | "claimFees" | "currentAndFutureRoundInfo" | "currentRoundInfo" | "currentSingleMarketRoundInfo" | "delistMarket" | "enterMarket" | "exitMarket" | "fees" | "getAllAvailableMarkets" | "getAllMarkets" | "getAmountOut" | "getBothMarkets" | "inputMarketRoundHistory" | "inputRoundInfo" | "inputSingleMarketRoundInfo" | "marketToDelistingRound" | "putMarketOnDelist" | "redeemPendingRoundsPerMarketId" | "redeemRoundsPerMarketIdCapped" | "registerMarket" | "resolveMarkets" | "roundStart" | "universalRound" | "updateAdmin" | "userDataPerCurrentRoundId" | "userDataPerMarketAndCurrentRoundId" | "userDataPerMarketIdAndRoundId" | "userDataPerMarketIdAndRoundIds" | "userDataPerRoundId" | "userToUnclaimedRounds" | "userUnclaimedRoundsDataPerMarketId" | "userUnclaimedRoundsPerMarketId" | "userUnclaimedRoundsPerMarketIdWithPage"): FunctionFragment;

    getEvent(nameOrSignatureOrTopic: "MarketEnter" | "MarketExit" | "MarketRedeem"): EventFragment;

    encodeFunctionData(functionFragment: 'checkResolutionStatus', values?: undefined): string;
encodeFunctionData(functionFragment: 'claimFees', values?: undefined): string;
encodeFunctionData(functionFragment: 'currentAndFutureRoundInfo', values?: undefined): string;
encodeFunctionData(functionFragment: 'currentRoundInfo', values?: undefined): string;
encodeFunctionData(functionFragment: 'currentSingleMarketRoundInfo', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'delistMarket', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'enterMarket', values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish]): string;
encodeFunctionData(functionFragment: 'exitMarket', values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish, BigNumberish, BigNumberish]): string;
encodeFunctionData(functionFragment: 'fees', values?: undefined): string;
encodeFunctionData(functionFragment: 'getAllAvailableMarkets', values?: undefined): string;
encodeFunctionData(functionFragment: 'getAllMarkets', values?: undefined): string;
encodeFunctionData(functionFragment: 'getAmountOut', values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish]): string;
encodeFunctionData(functionFragment: 'getBothMarkets', values?: undefined): string;
encodeFunctionData(functionFragment: 'inputMarketRoundHistory', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'inputRoundInfo', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'inputSingleMarketRoundInfo', values: [BigNumberish, BigNumberish]): string;
encodeFunctionData(functionFragment: 'marketToDelistingRound', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'putMarketOnDelist', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'redeemPendingRoundsPerMarketId', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'redeemRoundsPerMarketIdCapped', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'registerMarket', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'resolveMarkets', values?: undefined): string;
encodeFunctionData(functionFragment: 'roundStart', values?: undefined): string;
encodeFunctionData(functionFragment: 'universalRound', values?: undefined): string;
encodeFunctionData(functionFragment: 'updateAdmin', values: [AddressLike]): string;
encodeFunctionData(functionFragment: 'userDataPerCurrentRoundId', values: [AddressLike]): string;
encodeFunctionData(functionFragment: 'userDataPerMarketAndCurrentRoundId', values: [AddressLike, BigNumberish]): string;
encodeFunctionData(functionFragment: 'userDataPerMarketIdAndRoundId', values: [AddressLike, BigNumberish, BigNumberish]): string;
encodeFunctionData(functionFragment: 'userDataPerMarketIdAndRoundIds', values: [AddressLike, BigNumberish, BigNumberish[]]): string;
encodeFunctionData(functionFragment: 'userDataPerRoundId', values: [AddressLike, BigNumberish]): string;
encodeFunctionData(functionFragment: 'userToUnclaimedRounds', values: [AddressLike]): string;
encodeFunctionData(functionFragment: 'userUnclaimedRoundsDataPerMarketId', values: [AddressLike, BigNumberish, BigNumberish]): string;
encodeFunctionData(functionFragment: 'userUnclaimedRoundsPerMarketId', values: [AddressLike, BigNumberish]): string;
encodeFunctionData(functionFragment: 'userUnclaimedRoundsPerMarketIdWithPage', values: [AddressLike, BigNumberish, BigNumberish]): string;

    decodeFunctionResult(functionFragment: 'checkResolutionStatus', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'claimFees', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'currentAndFutureRoundInfo', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'currentRoundInfo', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'currentSingleMarketRoundInfo', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'delistMarket', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'enterMarket', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'exitMarket', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'fees', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'getAllAvailableMarkets', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'getAllMarkets', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'getAmountOut', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'getBothMarkets', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'inputMarketRoundHistory', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'inputRoundInfo', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'inputSingleMarketRoundInfo', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'marketToDelistingRound', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'putMarketOnDelist', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'redeemPendingRoundsPerMarketId', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'redeemRoundsPerMarketIdCapped', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'registerMarket', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'resolveMarkets', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'roundStart', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'universalRound', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'updateAdmin', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'userDataPerCurrentRoundId', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'userDataPerMarketAndCurrentRoundId', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'userDataPerMarketIdAndRoundId', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'userDataPerMarketIdAndRoundIds', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'userDataPerRoundId', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'userToUnclaimedRounds', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'userUnclaimedRoundsDataPerMarketId', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'userUnclaimedRoundsPerMarketId', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'userUnclaimedRoundsPerMarketIdWithPage', data: BytesLike): Result;
  }

  
    export namespace MarketEnterEvent {
      export type InputTuple = [MarketId: BigNumberish, RoundId: BigNumberish, User: AddressLike, AmountIn: BigNumberish, Side: BigNumberish, AmountOut: BigNumberish];
      export type OutputTuple = [MarketId: bigint, RoundId: bigint, User: string, AmountIn: bigint, Side: bigint, AmountOut: bigint];
      export interface OutputObject {MarketId: bigint, RoundId: bigint, User: string, AmountIn: bigint, Side: bigint, AmountOut: bigint };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace MarketExitEvent {
      export type InputTuple = [MarketId: BigNumberish, RoundId: BigNumberish, User: AddressLike, AmountInA: BigNumberish, AmountInB: BigNumberish, AmountOut: BigNumberish];
      export type OutputTuple = [MarketId: bigint, RoundId: bigint, User: string, AmountInA: bigint, AmountInB: bigint, AmountOut: bigint];
      export interface OutputObject {MarketId: bigint, RoundId: bigint, User: string, AmountInA: bigint, AmountInB: bigint, AmountOut: bigint };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace MarketRedeemEvent {
      export type InputTuple = [MarketId: BigNumberish, RoundId: BigNumberish, User: AddressLike, Result: BigNumberish, AmountOut: BigNumberish];
      export type OutputTuple = [MarketId: bigint, RoundId: bigint, User: string, Result: bigint, AmountOut: bigint];
      export interface OutputObject {MarketId: bigint, RoundId: bigint, User: string, Result: bigint, AmountOut: bigint };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

  export interface MarketMakerAMM extends BaseContract {
    
    connect(runner?: ContractRunner | null): MarketMakerAMM;
    waitForDeployment(): Promise<this>;

    interface: MarketMakerAMMInterface;

    
  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TypedEventLog<TCEvent>>>
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>
  on<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>
  
  once<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>
  once<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>
  removeAllListeners<TCEvent extends TypedContractEvent>(event?: TCEvent): Promise<this>


    
    
    checkResolutionStatus: TypedContractMethod<
      [],
      [[boolean, bigint, bigint] & {isResolvable: boolean, secondsLeft: bigint, currentRoundFees: bigint }],
      'view'
    >
    

    
    claimFees: TypedContractMethod<
      [],
      [void],
      'nonpayable'
    >
    

    
    currentAndFutureRoundInfo: TypedContractMethod<
      [],
      [[bigint, MarketMakerAMM.MarketDataWithHistoryStructOutput[], MarketMakerAMM.MarketDataWithHistoryStructOutput[]] & {roundId: bigint, marketDataCurrent: MarketMakerAMM.MarketDataWithHistoryStructOutput[], marketDataFuture: MarketMakerAMM.MarketDataWithHistoryStructOutput[] }],
      'view'
    >
    

    
    currentRoundInfo: TypedContractMethod<
      [],
      [MarketMakerAMM.MarketDataStructOutput[]],
      'view'
    >
    

    
    currentSingleMarketRoundInfo: TypedContractMethod<
      [marketId: BigNumberish, ],
      [MarketMakerAMM.MarketDataStructOutput],
      'view'
    >
    

    
    delistMarket: TypedContractMethod<
      [index: BigNumberish, ],
      [void],
      'nonpayable'
    >
    

    
    enterMarket: TypedContractMethod<
      [minAmountOut: BigNumberish, marketId: BigNumberish, roundId: BigNumberish, side: BigNumberish, ],
      [void],
      'payable'
    >
    

    
    exitMarket: TypedContractMethod<
      [minNativeAmountOut: BigNumberish, marketId: BigNumberish, roundId: BigNumberish, amountYes: BigNumberish, amountNo: BigNumberish, toBeExchanged: BigNumberish, ],
      [void],
      'nonpayable'
    >
    

    
    fees: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    getAllAvailableMarkets: TypedContractMethod<
      [],
      [bigint[]],
      'view'
    >
    

    
    getAllMarkets: TypedContractMethod<
      [],
      [bigint[]],
      'view'
    >
    

    
    getAmountOut: TypedContractMethod<
      [amountIn: BigNumberish, marketId: BigNumberish, roundId: BigNumberish, side: BigNumberish, ],
      [bigint],
      'view'
    >
    

    
    getBothMarkets: TypedContractMethod<
      [],
      [[bigint[], bigint[]]],
      'view'
    >
    

    
    inputMarketRoundHistory: TypedContractMethod<
      [marketId: BigNumberish, ],
      [MarketMakerAMM.MarketHistoryStructOutput[]],
      'view'
    >
    

    
    inputRoundInfo: TypedContractMethod<
      [roundId: BigNumberish, ],
      [MarketMakerAMM.MarketDataStructOutput[]],
      'view'
    >
    

    
    inputSingleMarketRoundInfo: TypedContractMethod<
      [marketId: BigNumberish, roundId: BigNumberish, ],
      [MarketMakerAMM.MarketDataWithHistoryStructOutput],
      'view'
    >
    

    
    marketToDelistingRound: TypedContractMethod<
      [marketId: BigNumberish, ],
      [bigint],
      'view'
    >
    

    
    putMarketOnDelist: TypedContractMethod<
      [index: BigNumberish, ],
      [void],
      'nonpayable'
    >
    

    
    redeemPendingRoundsPerMarketId: TypedContractMethod<
      [marketId: BigNumberish, ],
      [void],
      'nonpayable'
    >
    

    
    redeemRoundsPerMarketIdCapped: TypedContractMethod<
      [marketId: BigNumberish, ],
      [void],
      'nonpayable'
    >
    

    
    registerMarket: TypedContractMethod<
      [index: BigNumberish, ],
      [void],
      'nonpayable'
    >
    

    
    resolveMarkets: TypedContractMethod<
      [],
      [void],
      'nonpayable'
    >
    

    
    roundStart: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    universalRound: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    updateAdmin: TypedContractMethod<
      [newAdmin: AddressLike, ],
      [void],
      'nonpayable'
    >
    

    
    userDataPerCurrentRoundId: TypedContractMethod<
      [user: AddressLike, ],
      [MarketMakerAMM.UserDataStructOutput[]],
      'view'
    >
    

    
    userDataPerMarketAndCurrentRoundId: TypedContractMethod<
      [user: AddressLike, marketId: BigNumberish, ],
      [MarketMakerAMM.UserDataStructOutput],
      'view'
    >
    

    
    userDataPerMarketIdAndRoundId: TypedContractMethod<
      [user: AddressLike, marketId: BigNumberish, roundId: BigNumberish, ],
      [MarketMakerAMM.UserDataStructOutput],
      'view'
    >
    

    
    userDataPerMarketIdAndRoundIds: TypedContractMethod<
      [user: AddressLike, marketId: BigNumberish, roundIds: BigNumberish[], ],
      [MarketMakerAMM.UserDataStructOutput[]],
      'view'
    >
    

    
    userDataPerRoundId: TypedContractMethod<
      [user: AddressLike, roundId: BigNumberish, ],
      [MarketMakerAMM.UserDataStructOutput[]],
      'view'
    >
    

    
    userToUnclaimedRounds: TypedContractMethod<
      [user: AddressLike, ],
      [MarketMakerAMM.UserToRoundsPerMarketStructOutput[]],
      'view'
    >
    

    
    userUnclaimedRoundsDataPerMarketId: TypedContractMethod<
      [user: AddressLike, marketId: BigNumberish, page: BigNumberish, ],
      [[bigint, MarketMakerAMM.UserDataStructOutput[]] & {total: bigint, userData: MarketMakerAMM.UserDataStructOutput[] }],
      'view'
    >
    

    
    userUnclaimedRoundsPerMarketId: TypedContractMethod<
      [user: AddressLike, marketId: BigNumberish, ],
      [bigint[]],
      'view'
    >
    

    
    userUnclaimedRoundsPerMarketIdWithPage: TypedContractMethod<
      [user: AddressLike, marketId: BigNumberish, page: BigNumberish, ],
      [[bigint, bigint[]] & {total: bigint, roundIds: bigint[] }],
      'view'
    >
    


    getFunction<T extends ContractMethod = ContractMethod>(key: string | FunctionFragment): T;

    getFunction(nameOrSignature: 'checkResolutionStatus'): TypedContractMethod<
      [],
      [[boolean, bigint, bigint] & {isResolvable: boolean, secondsLeft: bigint, currentRoundFees: bigint }],
      'view'
    >;
getFunction(nameOrSignature: 'claimFees'): TypedContractMethod<
      [],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'currentAndFutureRoundInfo'): TypedContractMethod<
      [],
      [[bigint, MarketMakerAMM.MarketDataWithHistoryStructOutput[], MarketMakerAMM.MarketDataWithHistoryStructOutput[]] & {roundId: bigint, marketDataCurrent: MarketMakerAMM.MarketDataWithHistoryStructOutput[], marketDataFuture: MarketMakerAMM.MarketDataWithHistoryStructOutput[] }],
      'view'
    >;
getFunction(nameOrSignature: 'currentRoundInfo'): TypedContractMethod<
      [],
      [MarketMakerAMM.MarketDataStructOutput[]],
      'view'
    >;
getFunction(nameOrSignature: 'currentSingleMarketRoundInfo'): TypedContractMethod<
      [marketId: BigNumberish, ],
      [MarketMakerAMM.MarketDataStructOutput],
      'view'
    >;
getFunction(nameOrSignature: 'delistMarket'): TypedContractMethod<
      [index: BigNumberish, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'enterMarket'): TypedContractMethod<
      [minAmountOut: BigNumberish, marketId: BigNumberish, roundId: BigNumberish, side: BigNumberish, ],
      [void],
      'payable'
    >;
getFunction(nameOrSignature: 'exitMarket'): TypedContractMethod<
      [minNativeAmountOut: BigNumberish, marketId: BigNumberish, roundId: BigNumberish, amountYes: BigNumberish, amountNo: BigNumberish, toBeExchanged: BigNumberish, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'fees'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'getAllAvailableMarkets'): TypedContractMethod<
      [],
      [bigint[]],
      'view'
    >;
getFunction(nameOrSignature: 'getAllMarkets'): TypedContractMethod<
      [],
      [bigint[]],
      'view'
    >;
getFunction(nameOrSignature: 'getAmountOut'): TypedContractMethod<
      [amountIn: BigNumberish, marketId: BigNumberish, roundId: BigNumberish, side: BigNumberish, ],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'getBothMarkets'): TypedContractMethod<
      [],
      [[bigint[], bigint[]]],
      'view'
    >;
getFunction(nameOrSignature: 'inputMarketRoundHistory'): TypedContractMethod<
      [marketId: BigNumberish, ],
      [MarketMakerAMM.MarketHistoryStructOutput[]],
      'view'
    >;
getFunction(nameOrSignature: 'inputRoundInfo'): TypedContractMethod<
      [roundId: BigNumberish, ],
      [MarketMakerAMM.MarketDataStructOutput[]],
      'view'
    >;
getFunction(nameOrSignature: 'inputSingleMarketRoundInfo'): TypedContractMethod<
      [marketId: BigNumberish, roundId: BigNumberish, ],
      [MarketMakerAMM.MarketDataWithHistoryStructOutput],
      'view'
    >;
getFunction(nameOrSignature: 'marketToDelistingRound'): TypedContractMethod<
      [marketId: BigNumberish, ],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'putMarketOnDelist'): TypedContractMethod<
      [index: BigNumberish, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'redeemPendingRoundsPerMarketId'): TypedContractMethod<
      [marketId: BigNumberish, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'redeemRoundsPerMarketIdCapped'): TypedContractMethod<
      [marketId: BigNumberish, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'registerMarket'): TypedContractMethod<
      [index: BigNumberish, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'resolveMarkets'): TypedContractMethod<
      [],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'roundStart'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'universalRound'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'updateAdmin'): TypedContractMethod<
      [newAdmin: AddressLike, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'userDataPerCurrentRoundId'): TypedContractMethod<
      [user: AddressLike, ],
      [MarketMakerAMM.UserDataStructOutput[]],
      'view'
    >;
getFunction(nameOrSignature: 'userDataPerMarketAndCurrentRoundId'): TypedContractMethod<
      [user: AddressLike, marketId: BigNumberish, ],
      [MarketMakerAMM.UserDataStructOutput],
      'view'
    >;
getFunction(nameOrSignature: 'userDataPerMarketIdAndRoundId'): TypedContractMethod<
      [user: AddressLike, marketId: BigNumberish, roundId: BigNumberish, ],
      [MarketMakerAMM.UserDataStructOutput],
      'view'
    >;
getFunction(nameOrSignature: 'userDataPerMarketIdAndRoundIds'): TypedContractMethod<
      [user: AddressLike, marketId: BigNumberish, roundIds: BigNumberish[], ],
      [MarketMakerAMM.UserDataStructOutput[]],
      'view'
    >;
getFunction(nameOrSignature: 'userDataPerRoundId'): TypedContractMethod<
      [user: AddressLike, roundId: BigNumberish, ],
      [MarketMakerAMM.UserDataStructOutput[]],
      'view'
    >;
getFunction(nameOrSignature: 'userToUnclaimedRounds'): TypedContractMethod<
      [user: AddressLike, ],
      [MarketMakerAMM.UserToRoundsPerMarketStructOutput[]],
      'view'
    >;
getFunction(nameOrSignature: 'userUnclaimedRoundsDataPerMarketId'): TypedContractMethod<
      [user: AddressLike, marketId: BigNumberish, page: BigNumberish, ],
      [[bigint, MarketMakerAMM.UserDataStructOutput[]] & {total: bigint, userData: MarketMakerAMM.UserDataStructOutput[] }],
      'view'
    >;
getFunction(nameOrSignature: 'userUnclaimedRoundsPerMarketId'): TypedContractMethod<
      [user: AddressLike, marketId: BigNumberish, ],
      [bigint[]],
      'view'
    >;
getFunction(nameOrSignature: 'userUnclaimedRoundsPerMarketIdWithPage'): TypedContractMethod<
      [user: AddressLike, marketId: BigNumberish, page: BigNumberish, ],
      [[bigint, bigint[]] & {total: bigint, roundIds: bigint[] }],
      'view'
    >;

    getEvent(key: 'MarketEnter'): TypedContractEvent<MarketEnterEvent.InputTuple, MarketEnterEvent.OutputTuple, MarketEnterEvent.OutputObject>;
getEvent(key: 'MarketExit'): TypedContractEvent<MarketExitEvent.InputTuple, MarketExitEvent.OutputTuple, MarketExitEvent.OutputObject>;
getEvent(key: 'MarketRedeem'): TypedContractEvent<MarketRedeemEvent.InputTuple, MarketRedeemEvent.OutputTuple, MarketRedeemEvent.OutputObject>;

    filters: {
      
      'MarketEnter(uint256,uint256,address,uint256,uint256,uint256)': TypedContractEvent<MarketEnterEvent.InputTuple, MarketEnterEvent.OutputTuple, MarketEnterEvent.OutputObject>;
      MarketEnter: TypedContractEvent<MarketEnterEvent.InputTuple, MarketEnterEvent.OutputTuple, MarketEnterEvent.OutputObject>;
    

      'MarketExit(uint256,uint256,address,uint256,uint256,uint256)': TypedContractEvent<MarketExitEvent.InputTuple, MarketExitEvent.OutputTuple, MarketExitEvent.OutputObject>;
      MarketExit: TypedContractEvent<MarketExitEvent.InputTuple, MarketExitEvent.OutputTuple, MarketExitEvent.OutputObject>;
    

      'MarketRedeem(uint256,uint256,address,uint256,uint256)': TypedContractEvent<MarketRedeemEvent.InputTuple, MarketRedeemEvent.OutputTuple, MarketRedeemEvent.OutputObject>;
      MarketRedeem: TypedContractEvent<MarketRedeemEvent.InputTuple, MarketRedeemEvent.OutputTuple, MarketRedeemEvent.OutputObject>;
    
    };
  }